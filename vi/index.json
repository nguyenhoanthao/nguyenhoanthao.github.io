[
{
	"uri": "http://nguyenhoanthao.github.io/vi/lab2/1-setting-up-api-and-creating-lambda-function/",
	"title": "Thiết lập API và tạo hàm Lambda",
	"tags": [],
	"description": "",
	"content": " Thiết lập API\nTruy cập bảng điều khiển cổng API:\nAWS API gateway\nVui lòng đăng nhập vào AWS trước khi điều hướng. Bạn có thể chọn khu vực tùy ý để làm workshop này; trong workshop này tôi chọn US East (N. Virginia).\nCuộn xuống HTTP API và nhấn Build. Ở Step 1: Create an API: Nhấn Add integration. Nhấn chọn Lambda trong Integrations. Hiện tại chúng ta chưa có hàm Lambda nên chưa có lựa chọn ở đây, vì vậy chúng ta sẽ tạo hàm Lambda sau đó quay lại tiếp tục thiết lập API.\nTạo hàm Lambda\nTruy cập bảng điều khiển Lambda: AWS Lambda\nNhấn Create function. Chọn Author from scratch: Function name: DemoAppFunction Runtime: Python 3.8 Architecture: x86_64 Giữ nguyên các giá trị mặc định. Nhấn Create Function. Bây giờ chúng ta đã có hàm Lambda nên chúng ta sẽ chuyển qua tab thiết lập API trước đó để tiếp tục.\nTiếp tục thiết lập API\nQuay lại tab API còn đang thực hiện ở Step 2. Tại trường Lambda function, chọn hàm Lambda vừa khởi tạo. API name: Persons. Nhấn Next. Ở phần tiếp theo chúng ta sẽ cấu hình hai tuyến đường(GET và POST).\nỞ Configure Routes tuyến đường thứ nhất:\nMethod : GET. Resources path: /getPerson. Integration target: DemoAppFunction. Nhấn Add route. Tiếp tục với tuyến đường thứ hai:\nMethod : POST. Resources path: /createPerson. Integration target: DemoAppFunction. Nhấn Next. Ở Step 3: Define stages giữ nguyên các giá trị mặc định. Nhấn Next. Ở Step 4 chúng ta sẽ kiểm tra lại mọi thứ thiết lập trước đó, nếu mọi thứ đã ổn nhấn Create. Truy cập vào API chúng ta vừa tạo và nhấn vào Invoke URL. Chúng ta chưa thêm gì vào đường dẫn nên hiện tại không có ánh xạ nên chỉ phản hồi Not found. Bây giờ chúng ta sẽ thêm /getPerson cuối URL và nhấn Enter. Có thể thấy chúng ta đã gọi thành công hàm Lambda thông qua API gateway. Tuy nhiên đây chưa phải chức năng mà chúng ta mong muốn.\nTiếp tục thay đổi /getPerson thành /createPerson và nhấn Enter. Chúng ta nhận được phản hồi Not found vì chúng ta gọi createPerson trên trình duyệt tức là gọi bằng phương thức GET nhưng nó chỉ hỗ trợ phương thức POST. Để giải quyết vấn đề này và giúp chúng ta dễ dàng kiểm tra hơn thì PostMan sẽ là công cụ hỗ trợ điều này.\n"
},
{
	"uri": "http://nguyenhoanthao.github.io/vi/lab3/1-setting-up-api-gateway/",
	"title": "Thiết lập Cổng API và tạo hàm Lambda",
	"tags": [],
	"description": "",
	"content": " Thiết lập API\nTruy cập bảng điều khiển cổng API:\nAWS API gateway\nVui lòng đăng nhập vào AWS trước khi điều hướng. Bạn có thể chọn khu vực tùy ý để làm workshop này; trong workshop này tôi chọn US East (N. Virginia).\nCuộn xuống WebSocket API và nhấn Build. Ở Step 1: Specify API details, điền vào các trường thông tin sau:\nAPI name: socket-api Route selection expression: $request.body.action Nhấn Next. Ở Step 2: Add routes, nhấn:\nAdd $connect route Add $disconnect route Add $default route Ở phần Custom routes:\nNhấn Add Custom Routes Route key: setName Nhấn Add Custom Routes Route key: sendPublic Nhấn Add Custom Routes Route key: sendPrivate Nhấn Next Ở Step 3: Attach integrations:\nTất cả các trường Integration type chọn lambda Tất cả các trường AWS Region chọn us-east-1 (tùy vào khu vực bạn đang thực hiện workshop này) Hiện tại chúng ta chưa có hàm Lambda nên chưa có lựa chọn ở đây, vì vậy chúng ta sẽ tạo hàm Lambda sau đó quay lại tiếp tục thiết lập API.\nTạo hàm Lambda\nTruy cập bảng điều khiển Lambda: AWS Lambda\nNhấn Create function. Chọn Author from scratch: Function name: chat-api-handler Runtime: Node.js 20.x Architecture: x86_64 Giữ nguyên các giá trị mặc định. Sau đó nhấn Create function. Xuất hiện thông báo đã tạo hàm Lambda thành công. Copy Function ARN cho bước kế tiếp. Bây giờ chúng ta đã có hàm Lambda nên chúng ta sẽ chuyển qua tab thiết lập API trước đó để tiếp tục.\nTiếp tục thiết lập API\nQuay lại tab API còn đang thực hiện ở Step 3. Tại các trường Lambda function, chọn hoặc dán Function ARN đã copy trước đó. Sau đó nhấn Next. Ở Step 4: Add stages:\nĐiền Stage name: production. Sau đó nhấn Next. Tiếp theo kiểm tra lại thông tin và nhấn Create and deploy. Xuất hiện thông báo tạo API thành công. Chuyển vào tab Stages, bạn sẽ thấy WebSocket URL và connections URL. Lưu ý hai URL này để sử dụng cho các bước tiếp theo. "
},
{
	"uri": "http://nguyenhoanthao.github.io/vi/lab1/1-setting-up-sns/",
	"title": "Thiết lập SNS",
	"tags": [],
	"description": "",
	"content": "Thiết lập SNS Truy cập vào SNS console:\nAWS SNS Console Vui lòng đăng nhập vào AWS trước khi điều hướng, bạn có thể chọn khu vực tùy ý để làm workshop này, trong workshop này tôi chọn US East (N. Virginia)\nTạo một Topic mới: Nhấp vào Create topic. Đặt Type là “Standard”. Đặt Name là “API-Messages”. Trong Access policy, để Method là “Basic”. Thay đổi Define who can publish messages to the topic thành Only the specified AWS account và nhập ID tài khoản của bạn (tìm ở góc trên bên phải của console). Thay đổi Define who can subscribe to this topic thành Only the specified AWS accounts và nhập lại ID tài khoản của bạn. Trong thực tế, nên giới hạn thêm chỉ các tài nguyên cụ thể được phép gửi tin nhắn đến topic, nhưng trong ví dụ tạm thời này, giới hạn chỉ tài khoản là đủ an toàn.\nĐể các tùy chọn khác theo mặc định. Nhấp vào Create topic. Tạo một Subscription:\nTrên trang tiếp theo, nhấp vào Create subscription. Thay đổi Protocol thành “Email”. Trong trường Endpoint, nhập email cá nhân của bạn. Nhấp vào Create subscription. Xác nhận Subscription của bạn:\nBạn sẽ nhận được một email xác nhận ngay sau đó, với một liên kết bạn cần nhấp vào. Điều này xác nhận rằng bạn đồng ý nhận email từ topic và ngăn chặn spam được gửi qua SNS. Lưu ý: Email xác nhận có thể vào thư mục Spam trong Gmail, vì vậy đừng quên kiểm tra ở đó. Subscription của bạn bây giờ nên ở trạng thái Confirmed. "
},
{
	"uri": "http://nguyenhoanthao.github.io/vi/",
	"title": "Amazon API Gateway",
	"tags": [],
	"description": "",
	"content": "Amazon API Gateway Amazon API Gateway là dịch vụ được quản lý hoàn toàn của AWS, cho phép các nhà phát triển dễ dàng tạo, xuất bản, bảo trì, giám sát và bảo mật các API ở bất kỳ quy mô nào. Nó cho phép xây dựng các API mạnh mẽ và có thể mở rộng để các ứng dụng giao tiếp với các dịch vụ back-end, chẳng hạn như AWS Lambda, DynamoDB, hoặc các dịch vụ HTTP bên ngoài.\nCác loại API trong Amazon API Gateway: 1. REST APIs (RESTful APIs) Giới thiệu: Đây là loại API đầu tiên được hỗ trợ bởi API Gateway, tuân theo kiến trúc REST (Representational State Transfer), một chuẩn phổ biến để xây dựng dịch vụ web. Chức năng chính: Hỗ trợ tất cả các phương thức HTTP như GET, POST, PUT, DELETE, v.v. Tích hợp với AWS Lambda, DynamoDB, và các dịch vụ AWS khác hoặc endpoint HTTP/HTTPS bên ngoài. Cung cấp các tính năng mạnh mẽ như caching (bộ nhớ đệm), throttling (hạn chế tốc độ), và rate limiting (giới hạn tốc độ). Hỗ trợ các giải pháp bảo mật như Amazon Cognito, IAM roles, và Lambda Authorizers. Hỗ trợ việc quản lý nhiều phiên bản của API thông qua \u0026ldquo;Stages\u0026rdquo; (các môi trường như dev, test, prod). Ứng dụng: Phù hợp cho các API có yêu cầu tính năng đầy đủ, có thể mở rộng, yêu cầu xác thực phức tạp, theo dõi chặt chẽ và tích hợp mạnh mẽ với các dịch vụ AWS. 2. HTTP APIs Giới thiệu: HTTP APIs là một phiên bản nhẹ hơn, rẻ hơn của REST APIs, tối ưu cho hiệu suất và chi phí thấp hơn. Chức năng chính: Hỗ trợ các phương thức HTTP cơ bản như GET, POST, PUT, PATCH, DELETE. Tích hợp dễ dàng với AWS Lambda và các dịch vụ HTTP/HTTPS bên ngoài. Tính năng bảo mật cơ bản, hỗ trợ JWT Authorizers (OpenID Connect và Amazon Cognito). Độ trễ (latency) thấp hơn REST APIs và chi phí cũng thấp hơn. Ứng dụng: Thích hợp cho các API có yêu cầu đơn giản, chi phí thấp, hiệu suất cao mà không cần đến tính năng phức tạp của REST APIs. 3. WebSocket APIs Giới thiệu: WebSocket APIs được thiết kế để hỗ trợ giao tiếp hai chiều theo thời gian thực, phù hợp với các ứng dụng như chat, cập nhật thông báo, và các dịch vụ cần kết nối liên tục. Chức năng chính: Hỗ trợ giao tiếp hai chiều giữa client và server mà không cần thiết lập kết nối mới cho mỗi yêu cầu. Tích hợp với AWS Lambda và các dịch vụ khác để xử lý các thông điệp theo thời gian thực. Hỗ trợ quản lý kết nối, bao gồm theo dõi và ngắt kết nối. Hỗ trợ định tuyến thông điệp (message routing) dựa trên nội dung của thông điệp. Ứng dụng: Phù hợp cho các ứng dụng thời gian thực, như trò chuyện trực tuyến, trò chơi trực tuyến, ứng dụng tương tác hai chiều. Tóm tắt chức năng của từng loại API: REST APIs: Đầy đủ tính năng, hỗ trợ caching, throttling, rate limiting, các tùy chọn bảo mật mở rộng và tích hợp chặt chẽ với AWS. HTTP APIs: Nhẹ hơn, nhanh hơn và rẻ hơn, nhưng không có đầy đủ các tính năng nâng cao như REST APIs. Tập trung vào các API cơ bản với yêu cầu đơn giản. WebSocket APIs: Hỗ trợ giao tiếp thời gian thực hai chiều, phù hợp cho các ứng dụng như chat, thông báo thời gian thực. So sánh: Loại API Chức năng chính Trường hợp sử dụng REST APIs Đầy đủ tính năng, bảo mật mạnh mẽ, hỗ trợ tích hợp rộng Ứng dụng yêu cầu tính năng phức tạp, bảo mật, tính mở rộng HTTP APIs Nhẹ, nhanh, chi phí thấp hơn, bảo mật đơn giản Các ứng dụng yêu cầu hiệu suất cao, chi phí thấp, đơn giản WebSocket APIs Giao tiếp hai chiều thời gian thực, kết nối liên tục Ứng dụng thời gian thực (chat, thông báo, games) Amazon API Gateway cung cấp sự linh hoạt để lựa chọn loại API phù hợp với nhu cầu cụ thể của từng ứng dụng, từ các dịch vụ web truyền thống, dịch vụ vi mô đến các ứng dụng thời gian thực.\nVà trong workshop này chúng ta sẽ thực hành 3 bài lab để hiểu rõ hơn về AWS API gateway.\nNội dung chính REST APIs tích hợp Lambda, Mock và AWS Service HTTP APIs tích hợp Lambda và Postman WebSocket APIs tích hợp Lambda và WSCAT "
},
{
	"uri": "http://nguyenhoanthao.github.io/vi/lab1/",
	"title": "REST APIs tích hợp Lambda, Mock và AWS Service",
	"tags": [],
	"description": "",
	"content": "Tổng quan Chúng ta sẽ thiết lập API REST của API Gateway, với một số điểm cuối khác nhau, bao gồm tích hợp Mock, Lambda và dịch vụ AWS (SNS).\nBạn có thể đọc về sự khác biệt giữa API REST và HTTP tại đây: https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-vs-rest.html\nTrong bài lab này, chúng ta sẽ tìm hiểu cách sử dụng REST APIs bằng ách sử dụng API Gateway trong AWS, cùng với Tích hợp dịch vụ Mock, Lambda và Services AWS. Điều này sẽ cung cấp cho bạn trải nghiệm về tất cả các dịch vụ này cũng như cách triển khai các kiến ​​trúc đơn giản,serverless, kiến trúc back-end hướng sự kiện.\nTôi sẽ tạo lab này ở US East region (N. Virginia), vì vậy tất cả các liên kết đến bảng điều khiển sẽ ở đó. Đảm bảo bạn thay đổi khu vực nếu bạn đang triển khai ở nơi khác.\nNội dung chính Thiết lập SNS Tạo Lambda Tạo API Thử nghiệm API Dọn dẹp tài nguyên "
},
{
	"uri": "http://nguyenhoanthao.github.io/vi/lab2/",
	"title": "HTTP APIs tích hợp Lambda và Postman",
	"tags": [],
	"description": "",
	"content": "Tổng quan HTTP APIs trong AWS API Gateway là một loại API nhẹ, tối ưu cho các ứng dụng cần tính đơn giản, nhanh và chi phí thấp. Đây là phiên bản đơn giản hơn so với REST APIs, được thiết kế để đáp ứng các trường hợp sử dụng phổ biến như việc xây dựng các dịch vụ back-end cho các ứng dụng web hoặc mobile, hoặc tích hợp microservices.\nĐặc điểm chính của HTTP APIs: Hiệu suất cao hơn: HTTP APIs cung cấp độ trễ (latency) thấp hơn so với REST APIs nhờ thiết kế tối giản, giúp phản hồi nhanh hơn. Chi phí thấp: HTTP APIs thường rẻ hơn REST APIs do lược bỏ các tính năng phức tạp mà không phải ứng dụng nào cũng cần, chẳng hạn như Stage variables hoặc Lambda authorizers. Dễ tích hợp: HTTP APIs dễ dàng tích hợp với nhiều dịch vụ khác của AWS như AWS Lambda, Amazon S3 và các dịch vụ HTTP bên ngoài AWS. Hỗ trợ các phương thức HTTP: HTTP APIs hỗ trợ tất cả các phương thức HTTP cơ bản như GET, POST, PUT, PATCH, DELETE, giúp dễ dàng xây dựng các điểm cuối (endpoints) theo các chuẩn API thông dụng. Xác thực: HTTP APIs hỗ trợ các phương thức xác thực và phân quyền, bao gồm việc sử dụng JWT (JSON Web Tokens) với các nhà cung cấp OpenID Connect (OIDC) và Amazon Cognito. Không hỗ trợ một số tính năng nâng cao: HTTP APIs không có một số tính năng cao cấp của REST APIs như Stage variables, Request Validation hay API Gateway Authorizers (nhưng có hỗ trợ JWT authorizers). Trường hợp sử dụng: Xây dựng các ứng dụng web hoặc mobile backend có yêu cầu đơn giản về API. Tích hợp các microservices hoặc các ứng dụng đơn giản với chi phí và độ trễ thấp. Các dịch vụ cần tích hợp với AWS Lambda, DynamoDB hoặc các dịch vụ HTTP khác mà không cần các tính năng nâng cao của REST APIs. Trong bài lab này, chúng ta sẽ tìm hiểu cách xây dựng một HTTP APIs và thực nghiệm bằng phần mềm Postman. Bài lab này sẽ hướng dẫn bạn tạo một HTTP APIs bằng cách sử dụng API gateway trong AWS. Chúng ta sẽ tạo hai tuyến đường cho API, tuyến đầu tiên là /getPerson sẽ là một GET API và tuyến thứ hai sẽ là /createPerson là một POST API. Chúng sẽ được hỗ trợ bởi một hàm Lambda duy nhất và chúng ta sẽ thêm một số điều kiện logic vào hàm Lambda để nó có thể xử lý hai điểm cuối của hai tuyến đường này.\nMain Content Thiết lập API và tạo hàm Lambda Thực nghiệm API HTTP dùng Postman Dọn dẹp tài nguyên "
},
{
	"uri": "http://nguyenhoanthao.github.io/vi/lab3/2-lambda-function-code/",
	"title": "Mã hàm Lambda",
	"tags": [],
	"description": "",
	"content": " Mã hàm Lambda\nTruy cập bảng điều khiển Lambda:\nAWS Lambda\nTruy cập vào hàm chat-api-handler. Ở phần Code source, copy đoạn code sau và dán vào: import { ApiGatewayManagementApiClient, PostToConnectionCommand } from \u0026#34;@aws-sdk/client-apigatewaymanagementapi\u0026#34;; const ENDPOINT = \u0026#39;2ur7m6qwv6.execute-api.us-east-1.amazonaws.com/production\u0026#39;; /* QUAN TRỌNG: xóa \u0026#39;https://\u0026#39; và \u0026#39;@connections\u0026#39; khỏi URL kết nối mà bạn sao chép qua ví dụ: Connection URL https://xxxxxxxxxxx/execute-api.us-east-1.amazonaws.com/production/@connections sang: ENDPOINT = \u0026#39;xxxxxxxxxxx/execute-api.us-east-1.amazonaws.com/production/\u0026#39; */ const client = new ApiGatewayManagementApiClient({ endpoint: `https://${ENDPOINT}` }); /** * Gửi tin nhắn tới một client qua Connection ID */ const sendToOne = async (id, body) =\u0026gt; { try { const command = new PostToConnectionCommand({ ConnectionId: id, Data: Buffer.from(JSON.stringify(body)), }); await client.send(command); } catch (err) { console.error(`Error sending message to ${id}:`, err); } }; /** * Gửi tin nhắn tới tất cả các client */ const sendToAll = async (ids, body) =\u0026gt; { const all = ids.map(i =\u0026gt; sendToOne(i, body)); return Promise.all(all); }; export const handler = async (event) =\u0026gt; { if (event.requestContext) { const connectionId = event.requestContext.connectionId; const routeKey = event.requestContext.routeKey; let body = {}; try { if (event.body) { body = JSON.parse(event.body); } } catch (err) { console.error(\u0026#39;Failed to parse event body:\u0026#39;, err); } // Xử lý các action cụ thể dựa trên body.action if (body.action === \u0026#34;sendPublic\u0026#34;) { await sendToAll([connectionId], { publicMessage: \u0026#39;this is a public message\u0026#39; }); } else if (body.action === \u0026#34;sendPrivate\u0026#34;) { await sendToOne(connectionId, { privateMessage: \u0026#39;this is a private message\u0026#39; }); } // Xử lý các route mặc định của WebSocket ($connect, $disconnect, ...) switch (routeKey) { case \u0026#39;$connect\u0026#39;: console.log(`New connection: ${connectionId}`); break; case \u0026#39;$disconnect\u0026#39;: console.log(`Disconnected: ${connectionId}`); break; default: console.log(`Unhandled route: ${routeKey}`); } } const response = { statusCode: 200, body: JSON.stringify(\u0026#39;Message processed\u0026#39;), }; return response; }; Đoạn code trên là một hàm xử lý (handler) cho AWS Lambda, được thiết kế để xử lý các sự kiện WebSocket từ API Gateway. Dưới đây là tổng quan về các thành phần chính:\nKhởi tạo client của API Gateway:\nApiGatewayManagementApiClient và PostToConnectionCommand được import từ SDK của AWS để gửi tin nhắn qua WebSocket dựa trên Connection ID. ENDPOINT là URL của WebSocket API, được sử dụng để gửi các tin nhắn. Hàm sendToOne:\nDùng để gửi tin nhắn tới một client thông qua Connection ID. Tạo lệnh PostToConnectionCommand để gửi dữ liệu (tin nhắn) tới một client và gửi lệnh này thông qua client.send(command). Hàm sendToAll:\nGửi tin nhắn đến tất cả các client trong danh sách Connection IDs. Sử dụng Promise.all để đảm bảo tin nhắn được gửi đến tất cả các client. Hàm xử lý chính handler:\nNhận sự kiện: Thực thi khi API Gateway nhận được một sự kiện WebSocket (như kết nối mới, ngắt kết nối, hoặc tin nhắn gửi từ client). Xử lý thông tin sự kiện: Kiểm tra các thuộc tính từ event.requestContext để lấy thông tin về Connection ID và Route Key (xác định loại sự kiện như $connect, $disconnect). Nếu có body, hàm sẽ cố gắng parse nó thành JSON để xử lý. Xử lý hành động: Dựa vào body.action (ví dụ: sendPublic, sendPrivate), hàm sẽ thực hiện gửi tin nhắn công khai hoặc riêng tư qua WebSocket. Xử lý các route WebSocket mặc định: $connect: Log khi có một kết nối mới. $disconnect: Log khi một client ngắt kết nối. Tóm lại, đoạn code này thực hiện việc gửi tin nhắn qua WebSocket tới các client dựa trên các hành động từ phía client, đồng thời xử lý các sự kiện kết nối và ngắt kết nối từ WebSocket API Gateway.\nTriển khai\nSau khi dán đoạn code trên, nhấn Deploy. Thông báo đã cập nhạt hàm Lambda. Vào tab Configuration -\u0026gt; Permissions. Mở rộng tab Role name. Bây giờ chúng ta đã truy cập vào tab IAM. Nhấn vào Add permission -\u0026gt; Attach policies. Tích chọn AmazonAPIGatewayInvokefullAccess Nhấn Add permission.\nTa nhận được thông báo thêm quyền thành công. Quay lại tab Lambda chúng ta có thể thấy chính sách đã được đính kèm. "
},
{
	"uri": "http://nguyenhoanthao.github.io/vi/lab2/2-http-api-experiment-with-postman/",
	"title": "Thực nghiệm HTTP APIs dùng Postman",
	"tags": [],
	"description": "",
	"content": "Postman là một công cụ phổ biến dùng để phát triển, kiểm thử và tài liệu hóa các API. Nó cung cấp giao diện đơn giản, thân thiện để bạn có thể dễ dàng gửi các yêu cầu HTTP, nhận phản hồi từ server, và kiểm tra các endpoint của API. (Tải Postman tại đây)\nThực hiện trên Postman\nGiao diện chính của Postman: Tạo tab mới. Quay lại tab API gateway copy Invoke URL. Tại Postman chọn phương thức GET và dán link Invoke URL và thêm /getPerson vào URL. Nhấn Send và chúng ta vẫn nhận được phản hồi Hello from Lambda!. Chúng ta thử tạo một cặp key - value: personid - personid 123. Có thể thấy 2 tham số này được thêm vào URL truy vấn. Nhấn Send và chúng ta vẫn nhận được phản hồi Hello from Lambda!. Bây giờ chúng ta sẽ tạo một tab mới với phương thức POST và thêm /createPerson vào URL. Nhấn vào tab Body rồi tích chọn raw. Thêm vào raw: {\r\u0026#34;firstName\u0026#34;: \u0026#34;Daniel\u0026#34;,\r\u0026#34;lastName\u0026#34;: \u0026#34;G\u0026#34;,\r\u0026#34;email\u0026#34;: \u0026#34;myEmail@gmail.com\u0026#34;\r} Thực nghiệm trên Postman\nQuay trở lại tab Lambda function và sửa code hàm Lambda như sau: import json import uuid GET_RAW_PATH = \u0026#34;/getPerson\u0026#34; CREATE_RAW_PATH = \u0026#34;/createPerson\u0026#34; def lambda_handler(event, context): print(json.dumps(event, indent=2)) # In toàn bộ event để kiểm tra # Kiểm tra nếu rawPath tồn tại trong event if \u0026#39;rawPath\u0026#39; in event: # Xử lý phương thức GET if event[\u0026#39;rawPath\u0026#39;] == GET_RAW_PATH: print(\u0026#39;Received getPerson request\u0026#39;) personId = event[\u0026#39;queryStringParameters\u0026#39;][\u0026#39;personid\u0026#39;] print(\u0026#34;with param personId=\u0026#34; + personId) return { \u0026#34;firstName\u0026#34;: \u0026#34;Daniel \u0026#34; + personId, \u0026#34;lastName\u0026#34;: \u0026#34;G\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;myEmail@gmail.com\u0026#34; } # Xử lý phương thức POST elif event[\u0026#39;rawPath\u0026#39;] == CREATE_RAW_PATH and event[\u0026#39;requestContext\u0026#39;][\u0026#39;http\u0026#39;][\u0026#39;method\u0026#39;] == \u0026#39;POST\u0026#39;: print(\u0026#39;Received createPerson request\u0026#39;) # Giải mã body từ JSON decodedBody = json.loads(event[\u0026#39;body\u0026#39;]) firstname = decodedBody.get(\u0026#39;firstname\u0026#39;, \u0026#39;Unknown\u0026#39;) # Tránh lỗi nếu không có \u0026#39;firstname\u0026#39; print(\u0026#39;with param firstname=\u0026#39; + firstname) # Tạo một ID cho người dùng mới và trả về return { \u0026#34;statusCode\u0026#34;: 200, \u0026#34;body\u0026#34;: json.dumps({ \u0026#34;personId\u0026#34;: str(uuid.uuid1())}) } # Nếu không tìm thấy rawPath hoặc không hợp lệ return { \u0026#34;statusCode\u0026#34;: 400, \u0026#34;body\u0026#34;: json.dumps({\u0026#34;message\u0026#34;: \u0026#34;Invalid request\u0026#34;}) } Chức năng của đoạn code\nGET /getPerson:\nLấy thông tin một người dựa trên personId từ tham số queryStringParameters. Trả về tên, họ, và email của người đó. POST /createPerson:\nTạo một người mới với thông tin firstname lấy từ body. Trả về một personId ngẫu nhiên. Nhấn Deloy để triển khai hàm Lambda.\nQuay lại Postman tại tab phương thức GET và nhấn Send. Ta nhận được phản hồi: Tiếp theo qua tab phương thức POST và nhấn Send. Tiếp tục ấn Send ta nhận một personId khác(ngẫu nhiên). "
},
{
	"uri": "http://nguyenhoanthao.github.io/vi/lab1/2-create-the-lambda/",
	"title": "Tạo Lambda",
	"tags": [],
	"description": "",
	"content": " Truy cập vào Lambda console:\nAWS Lambda Console\nTạo một hàm mới:\nNhấp vào Create function. Để mặc định lựa chọn Author from scratch. Đặt Function name là api-return-ip. Đặt Runtime là “Python 3.9”. Giữ nguyên Architecture là “x86_64”. Nhấp vào Create function. Thêm mã code vào hàm Lambda:\nTrong tab Code, nhập đoạn mã sau:\ndef lambda_handler(event, context): return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;headers\u0026#39;: {}, \u0026#39;body\u0026#39;: event[\u0026#39;requestContext\u0026#39;][\u0026#39;identity\u0026#39;][\u0026#39;sourceIp\u0026#39;], \u0026#39;isBase64Encoded\u0026#39;: False } Đây là một hàm rất cơ bản, chỉ đơn giản trả về địa chỉ IP của người gửi yêu cầu (bạn).\nĐừng quên nhấp vào Deploy để lưu hàm này. "
},
{
	"uri": "http://nguyenhoanthao.github.io/vi/lab2/3-cleaning-up/",
	"title": "Dọn dẹp tài nguyên",
	"tags": [],
	"description": "",
	"content": " Truy cập vào bảng điều AWS Lambda\nAWS Lambda\nNhấn chọn DemoAppFunction. Nhấn Action -\u0026gt; Delete Xác nhận xóa. Truy cập vào bảng điều AWS API\nAWS API\nChọn Persons. Nhấn Delete. Xác nhận xóa. "
},
{
	"uri": "http://nguyenhoanthao.github.io/vi/lab3/3-testing-the-websocket-using-wscat/",
	"title": "Kiểm tra WebSocket APIs bằng wscat",
	"tags": [],
	"description": "",
	"content": " Cài đặt wscat\nCài đặt wscat ở terminal. Câu lệnh: npm install -g wscat. Chuyển hướng đến tab API gateway, copy WebSocket URL. Bây giờ tại terminal chúng ta sẽ mở 2 cửa sổ(cửa sổ 1 và cửa sổ 2). Tại cửa sổ 1 chúng ta sẽ gõ lệnh: wscat -c wss://2ur7m6qwv6.execute-api.us-east-1.amazonaws.com/production/ Bạn cần thay thế WebSocket của bạn đã copy ở buớc truớc.\nSau đó nhấn Enter. Chúng ta đã kết nối đến WebSocket thành công. Tương tự với cửa sổ 2. Từ cửa sổ 1 gõ một JSON đến Socket: {\u0026quot;action\u0026quot; : \u0026quot;sendPublic\u0026quot;} Ta sẽ nhận được phản hổi: Từ cửa sổ 2 gõ một JSON đến Socket: {\u0026quot;action\u0026quot; : \u0026quot;sendPrivate\u0026quot;} Ta sẽ nhận được phản hồi: Có thể thấy khi một user gửi tin nhắn đến Socket thì chỉ người dùng đó nhận được phản hồi, vì vậy chúng ta sẽ cập nhật code hàm Lambda để khi một người dùng gửi tin nhắn thì các người dùng khác đều nhận được phản hồi.\nCập nhật code hàm Lambda\nChúng ta sẽ dùng đoạn mã dưới đây:\nimport { ApiGatewayManagementApiClient, PostToConnectionCommand } from \u0026#34;@aws-sdk/client-apigatewaymanagementapi\u0026#34;; const ENDPOINT = \u0026#39;2ur7m6qwv6.execute-api.us-east-1.amazonaws.com/production\u0026#39;; /* QUAN TRỌNG: xóa \u0026#39;https://\u0026#39; và \u0026#39;@connections\u0026#39; khỏi URL kết nối mà bạn sao chép qua ví dụ: Connection URL https://xxxxxxxxxxx/execute-api.us-east-1.amazonaws.com/production/@connections sang: ENDPOINT = \u0026#39;xxxxxxxxxxx/execute-api.us-east-1.amazonaws.com/production/\u0026#39; */ const client = new ApiGatewayManagementApiClient({ endpoint: `https://${ENDPOINT}` }); const names = {}; /** * Gửi tin nhắn tới một client qua Connection ID */ const sendToOne = async (id, body) =\u0026gt; { try { const command = new PostToConnectionCommand({ ConnectionId: id, Data: Buffer.from(JSON.stringify(body)), }); await client.send(command); } catch (err) { console.error(`Error sending message to ${id}:`, err); } }; /** * Gửi tin nhắn tới tất cả các client */ const sendToAll = async (ids, body) =\u0026gt; { const all = ids.map(i =\u0026gt; sendToOne(i, body)); return Promise.all(all); }; export const handler = async (event) =\u0026gt; { if (event.requestContext) { const connectionId = event.requestContext.connectionId; const routeKey = event.requestContext.routeKey; let body = {}; try { if (event.body) { body = JSON.parse(event.body); } } catch (err) { console.error(\u0026#39;Failed to parse event body:\u0026#39;, err); } // Xử lý các action cụ thể dựa trên body.action switch (routeKey) { case \u0026#39;$connect\u0026#39;: console.log(`New connection: ${connectionId}`); break; case \u0026#39;$disconnect\u0026#39;: await sendToAll(Object.keys(names), { systemMessage: `${names[connectionId]} has left the chat` }); delete names[connectionId]; await sendToAll(Object.keys(names), { members: Object.values(names) }); console.log(`Disconnected: ${connectionId}`); break; case \u0026#39;setName\u0026#39;: names[connectionId] = body.name; await sendToAll(Object.keys(names), { members: Object.values(names) }); await sendToAll(Object.keys(names), { systemMessage: `${names[connectionId]} has joined the chat` }); break; case \u0026#39;sendPublic\u0026#39;: await sendToAll(Object.keys(names), { publicMessage: `${names[connectionId]}: ${body.message}` }); break; case \u0026#39;sendPrivate\u0026#39;: const to = Object.keys(names).find(key =\u0026gt; names[key] === body.to); if (to) { await sendToOne(to, { privateMessage: `${names[connectionId]}: ${body.message}` }); } else { await sendToOne(connectionId, { errorMessage: `User ${body.to} not found.` }); } break; default: console.log(`Unhandled route: ${routeKey}`); } } const response = { statusCode: 200, body: JSON.stringify(\u0026#39;Message processed\u0026#39;), }; return response; }; Chức năng gửi tin nhắn cho tất cả các client trong đoạn mã mới được thực hiện qua hàm sendToAll. Hàm này nhận một danh sách các Connection ID (danh sách ids), đại diện cho tất cả các client hiện đang kết nối, cùng với nội dung tin nhắn (body) cần gửi.\nNhấn Deploy để cập nhật. Thông báo đã cập nhật thành công. Kiểm tra lại với hàm Lambda vừa cập nhật\nTiếp tục mở 2 cửa sổ terminal kết nối với websocket.\nỞ cửa sổ 1:\n{\u0026quot;action\u0026quot;: \u0026quot; setName \u0026quot;, \u0026quot; name \u0026quot;: \u0026quot; bob \u0026quot;} Ta nhận đuợc phản hồi: Ở cửa sổ 2:\n{\u0026quot;action\u0026quot;: \u0026quot; setName \u0026quot;, \u0026quot; name \u0026quot;: \u0026quot; alice \u0026quot;} Ta nhận được phản hồi:\nBây giờ chúng ta qua cửa sổ 1 sẽ thấy phản hồi:\nTiếp tục ở cửa sổ 2:\n{\u0026quot;action\u0026quot;: \u0026quot;sendPublic\u0026quot;, \u0026quot;message\u0026quot;: \u0026quot;Hello World!\u0026quot;} Qua cửa sổ 1 kiểm tra:\nQua cửa sổ 2:\n{\u0026quot;action\u0026quot;: \u0026quot;sendPrivate\u0026quot;, \u0026quot;message\u0026quot;: \u0026quot;this is private\u0026quot;, \u0026quot;to\u0026quot;: \u0026quot;bob\u0026quot;} Qua cửa sổ 1 kiểm tra:\nBây giờ hãy ngắt kết nối ở cửa sổ 2:\nCtrl + C Lúc này ở Terminal ở cửa sổ 1 sẽ thông báo:\nVừa rồi là một chuỗi thao tác với hai cửa sổ khác nhau liên quan đến việc gửi tin nhắn công khai và riêng tư trong một hệ thống kết nối. Dưới đây là tóm tắt các bước:\nCửa sổ 1: Gửi yêu cầu đặt tên là \u0026ldquo;bob\u0026rdquo; và nhận được phản hồi.\nCửa sổ 2: Gửi yêu cầu đặt tên là \u0026ldquo;alice\u0026rdquo; và nhận được phản hồi tương tự.\nQuay lại cửa sổ 1: Kiểm tra và thấy thông báo phản hồi rằng tên \u0026ldquo;alice\u0026rdquo; đã được đặt ở cửa sổ 2.\nCửa sổ 2: Gửi tin nhắn công khai \u0026ldquo;Hello World!\u0026rdquo;.\nQuay lại cửa sổ 1: Kiểm tra và thấy tin nhắn công khai từ cửa sổ 2.\nCửa sổ 2: Gửi tin nhắn riêng tư với nội dung \u0026ldquo;this is private\u0026rdquo; cho \u0026ldquo;bob\u0026rdquo;.\nQuay lại cửa sổ 1: Kiểm tra và thấy tin nhắn riêng tư từ \u0026ldquo;alice\u0026rdquo;.\nCửa sổ 2: Ngắt kết nối bằng cách dùng Ctrl + C.\nCửa sổ 1: Nhận thông báo rằng kết nối ở cửa sổ 2 đã bị ngắt.\n"
},
{
	"uri": "http://nguyenhoanthao.github.io/vi/lab1/3-create-the-api/",
	"title": "Tạo API",
	"tags": [],
	"description": "",
	"content": " Truy cập vào API Gateway console:\nAWS API Gateway Console\nTạo một API mới:\nNhấp vào Create API. Chọn REST API → Build. Đảm bảo không chọn “REST API Private”. Để mặc định các tùy chọn Protocol và Create new API, và đặt tên API theo ý bạn. Nhấp vào Create API. Tạo một Resource cho Mock Integration:\nSau khi tạo API xong, bạn sẽ thấy tất cả các “Resources” (endpoint / đường dẫn API). Hiện tại chưa có resource nào, vì vậy nhấp chọn Create Resource. Đặt tên resource đầu tiên này là “Mock”. Resource Path sẽ là đường dẫn URL bạn sẽ sử dụng để gọi, ví dụ như:\nhttps://abcdef1234.execute-api.ap-southeast-2.amazonaws.com/Mock Gắn một Method cho Resource:\nMột Method là phương thức HTTP mà resource (đường dẫn) sẽ chấp nhận, chẳng hạn như “GET”, “POST”, “DELETE”, v.v.\nĐối với Mock integration, chúng ta sẽ sử dụng “GET”.\nĐảm bảo bạn đang ở trong resource /Mock.\nNhấp vào Create Method. Chọn GET.\nSau đó, API Gateway sẽ hiển thị danh sách các tích hợp có thể. Đối với mục này, chọn “Mock” rồi nhấp vào Create method. Sau khi lưu, nhấp vào Integration Response. Ấn Edit. Nhấp vào dấu tick, sau đó trong phần template, nhập đoạn mã sau (bạn có thể thay đổi thông báo nếu muốn):\n{ \u0026#34;statusCode\u0026#34;: 200, \u0026#34;message\u0026#34;: \u0026#34;This response is mocking you\u0026#34; } Nhấp vào Save. Tạo Resource cho Lambda Integration:\nQuay lại resource gốc (/). Nhấp Create Resource. Đặt tên resource là “Lambda” và giữ Resource Path là /Lambda. Nhấp vào Create Resource. Nhấp Create Method. Phương thức này cũng sẽ là “GET”. Trên trang tiếp theo, đặt Integration type là “Lambda function”. Bật Lambda Proxy integration. Nhấp vào trường Lambda Function, nó sẽ hiển thị danh sách các Lambda trong khu vực của bạn, chọn Lambda bạn đã tạo trước đó. Để mặc định các tùy chọn khác và nhấp Create method. Tạo Resource cho SNS Integration:\nĐối với bước này, bạn cần tạo một IAM Role mà API Gateway sẽ sử dụng để gửi tin nhắn đến SNS.\nTruy cập vào IAM Console.\nVào trang Roles, nhấp vào Create Role. Dưới Trusted entity, chọn AWS Service, và trong drop-down, chọn API Gateway. Đảm bảo chọn radio button cho API Gateway.\nNhấp Next. Trên trang Permissions, nhấp Next. Cuối cùng, đặt tên role là api-gw-sns-role rồi nhấp Create role. Vào role vừa tạo, nhấp Add permissions rồi chọn Create inline policy. Vào tab JSON và nhập đoạn mã sau:\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;sns:Publish\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; } ] } Nhấp vào Next. Đặt tên là SnsPublish và nhấp Create policy. Trên trang tóm tắt, sao chép ARN của role bạn vừa tạo, bạn sẽ cần nó cho bước tiếp theo. Cấu hình SNS Integration trên API Gateway:\nQuay lại API Gateway Console. Vào lại REST API của bạn. Quay lại resource gốc (/). Nhấp chọn Create Resource. Đặt tên resource là “SNS” và giữ Resource Path là /SNS. Nhấp vào Create Resource. Nhấp chọn Create Method. Phương thức này sẽ là “POST”. Trên trang tiếp theo, đặt Integration type là “AWS Service”. Đặt AWS Region là cùng khu vực với API / SNS của bạn (ví dụ: ap-southeast-2). Đặt AWS Service là “Simple Notification Service (SNS)”. Để trống AWS Subdomain. Đặt HTTP method là POST. Để Action Type là “Use action name”. Đặt Action là Publish. Dưới Execution Role, nhập ARN của IAM Role bạn vừa tạo cho SNS.(Bạn đã copy ở bước trước đó.) Để mặc định các tùy chọn khác và nhấp Create method. Cấu hình các tham số truy vấn cho SNS:\nQuay lại resource /SNS và phương thức POST, nhấp vào Method Request. Click on Edit. Dưới URL Query String Parameters, nhấp Add query string và nhập TopicArn. Nhấp Add query string và nhập Message, sau đó nhấp vào Save. Quay lại resource /SNS và phương thức POST, nhấp vào Integration Request. Nhấp chọn Edit. Dưới URL Query String Parameters, nhấp Add query string parameter. Đặt Name là Message và Mapped from là method.request.querystring.Message. Nhấp Add query string một lần nữa. Đặt Name là TopicArn và Mapped from là method.request.querystring.TopicArn. Nhấp vào Save. Triển khai API:\nNhấp vào Deploy API. Trong cửa sổ bật lên, đặt Deployment stage là [New Stage] và Stage name là v1. Stage name có thể là bất kỳ tên nào, được sử dụng để điều hướng yêu cầu API đến các “phiên bản” khác nhau của API, ví dụ: dev, prod, hoặc chỉ đơn giản là v1, v2, v.v. Nhấp Deploy. Sau khi triển khai, bạn sẽ được chuyển đến trang Stage Editor, nơi bạn có thể cài đặt các tùy chọn như Rate Limiting, WAF associations, caching, logs, v.v. Trong demo này, bạn không cần thay đổi bất kỳ thiết lập nào. Ở đầu màn hình, bạn sẽ thấy URL của API. Sao chép URL đó cho bước tiếp theo. "
},
{
	"uri": "http://nguyenhoanthao.github.io/vi/lab3/",
	"title": "WebSocket APIs tích hợp Lambda và WSCAT ",
	"tags": [],
	"description": "",
	"content": "Tổng quan WebSocket APIs trong API Gateway là một tập hợp các tuyến đường WebSocket được tích hợp với các điểm cuối HTTP backend, các hàm Lambda, hoặc các dịch vụ AWS khác. Bạn có thể sử dụng các tính năng của API Gateway để hỗ trợ tất cả các khía cạnh của vòng đời API, từ việc tạo ra đến việc giám sát các API trong môi trường sản xuất của bạn.\nAPI Gateway WebSocket APIs là hai chiều. Một khách hàng có thể gửi tin nhắn đến một dịch vụ, và các dịch vụ có thể gửi tin nhắn đến khách hàng một cách độc lập. Hành vi hai chiều này cho phép các tương tác giữa khách hàng và dịch vụ phong phú hơn vì các dịch vụ có thể đẩy dữ liệu đến khách hàng mà không yêu cầu khách hàng phải thực hiện yêu cầu rõ ràng. WebSocket APIs thường được sử dụng trong các ứng dụng thời gian thực như ứng dụng chat, nền tảng hợp tác, trò chơi nhiều người chơi, và nền tảng giao dịch tài chính.\nTrong bài lab này, chúng ta sẽ tìm hiểu cách xây dựng cuộc trò chuyện cơ bản bằng Lambda, WebSocket APIs, WSCAT. Chúng ta xây dựng một cuộc trò chuyện đơn giản theo thời gian thực sử dụng websocket được hỗ trợ bởi hàm lambda AWS và Amazon API Gateway. Ứng dụng gửi JSON qua websocket để gửi tin nhắn trò chuyện và thông báo trong thời gian thực, qua đường dây liên lạc hai chiều, tới tất cả người dùng trò chuyện.\nNội dung chính Thiết lập cổng API và Tạo hàm Lambda Mã hàm Lambda Kiểm tra WebSocket bằng wscat Dọn dẹp tài nguyên "
},
{
	"uri": "http://nguyenhoanthao.github.io/vi/lab3/4-cleaning-up/",
	"title": "Dọn dẹp tài nguyên",
	"tags": [],
	"description": "",
	"content": " Truy cập vào bảng điều AWS Lambda\nAWS Lambda\nNhấn chọn chat-api-hendler.\nNhấn Action -\u0026gt; Delete Xác nhận xóa. Truy cập vào bảng điều AWS API\nAWS API\nChọn Socket API.\nNhấn Delete. Xác nhận xóa. "
},
{
	"uri": "http://nguyenhoanthao.github.io/vi/lab1/4-testing-the-api/",
	"title": "Thử nghiệm API",
	"tags": [],
	"description": "",
	"content": "Lambda và Mock có thể được kiểm tra trong trình duyệt. Theo mặc định, bất kỳ URL nào bạn nhập vào trình duyệt đều thực hiện yêu cầu GET (và hãy nhớ rằng chỉ tài nguyên Lambda và Mock của chúng ta mới có bộ phương thức GET).\nMock Nếu chúng ta truy cập URL API của mình và nối thêm /Mock, chúng ta sẽ thấy phản hồi mà chúng ta đã nhập trước đó. Lý do chúng ta muốn một đầu ra JSON thay vì một đầu ra thân thiện với con người có thể đọc được là vì làm việc với JSON trong các ngôn ngữ lập trình giúp mọi việc dễ dàng hơn nhiều. Mã hoặc ứng dụng của bạn có thể đọc khóa statusCode và thấy giá trị 200, sau đó nó có thể đọc khóa message và xem giá trị của nó.\nLambda Bây giờ, nếu truy cập URL /Lambda, chúng ta sẽ thấy phản hồi của hàm (địa chỉ IP của bạn). SNS Bảng điều khiển API Gateway cung cấp một cách thuận tiện để kiểm tra API của bạn. Trên trang thử nghiệm, bên dưới Chuỗi truy vấn, hãy nhập thông tin sau. Thay thế TopicArn bằng ARN chủ đề SNS của bạn và Tin nhắn bằng bất cứ điều gì bạn thích:\nTopicArn=arn:aws:sns:REGION:ACCOUNT-ID:API-Messages\u0026amp;Message=Cats+Are+Amazing Nếu bạn muốn sử dụng dấu cách trong tin nhắn của mình, vì tham số truy vấn được mã hóa URL nên dấu cách cần được thay thế bằng dấu +.\nCuộn xuống và nhấp vào Test. Vào kiểm tra mail "
},
{
	"uri": "http://nguyenhoanthao.github.io/vi/lab1/5-cleaning-up/",
	"title": "Dọn dẹp tài nguyên",
	"tags": [],
	"description": "",
	"content": " Truy cập vào console API Gateway: API Gateway Console\nChọn API bạn đã tạo, sau đó nhấn Delete. Xác nhận xóa. Truy cập vào console SNS: SNS Console\nVào mục Topics, chọn chủ đề bạn đã tạo trước đó, và nhấn Delete. Xác nhận xóa. Vào mục Subscriptions, chọn Subscriptions bạn đã tạo trước đó, và nhấn Delete. Truy cập vào console IAM: IAM Console\nTrong Roles, tìm kiếm api-gw-sns-role. Chọn vai trò bạn đã tạo trước đó, và nhấn Delete. Gõ api-gw-sns-role vào ô xác nhận, và nhấn Delete. Truy cập vào console Lambda: Lambda Console\nChọn hàm bạn đã tạo trước đó, nhấn Actions rồi chọn Delete. Gõ delete vào cửa sổ xác nhận, sau đó nhấn Delete. Xóa thêm role được sinh ra khi tạo hàm Lambda. Chọn Delete. Truy cập vào console CloudWatch Logs: CloudWatch Logs Console\nTìm kiếm api-return-ip Log Group, chọn nhóm log, nhấn Actions rồi chọn Delete. Trong cửa sổ xác nhận, nhấn Delete. "
},
{
	"uri": "http://nguyenhoanthao.github.io/vi/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://nguyenhoanthao.github.io/vi/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]