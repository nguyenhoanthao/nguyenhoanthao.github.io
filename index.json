[
{
	"uri": "http://nguyenhoanthao.github.io/lab2/1-setting-up-api-and-creating-lambda-function/",
	"title": "Setting up API and Creating Lambda Function",
	"tags": [],
	"description": "",
	"content": " Setting up API\nAccess the API Gateway console:\nAWS API Gateway\nPlease log in to AWS before navigating. You can choose any region to do this workshop; in this workshop, I chose US East (N. Virginia).\nScroll down to HTTP API and click Build. In Step 1: Create an API, click Add integration. Select Lambda under Integrations. We don\u0026rsquo;t have a Lambda function yet, so there\u0026rsquo;s no option available here. We will create a Lambda function and then return to continue setting up the API.\nCreating Lambda Function\nAccess the Lambda console:\nAWS Lambda\nClick Create function. Choose Author from scratch: Function name: DemoAppFunction Runtime: Python 3.8 Architecture: x86_64 Keep the default settings. Click Create Function. Now that we have a Lambda function, we can return to the API setup tab to continue.\nContinuing API Setup\nReturn to the API tab in Step 2. In the Lambda function field, select the Lambda function just created. API name: Persons. Click Next. In the next step, we will configure two routes (GET and POST).\nIn Configure Routes, the first route:\nMethod: GET. Resources path: /getPerson. Integration target: DemoAppFunction. Click Add route.\nNow for the second route:\nMethod: POST. Resources path: /createPerson. Integration target: DemoAppFunction. Click Next. In Step 3: Define stages, keep the default values. Click Next. In Step 4, review everything, and if it looks good, click Create. Access the API you just created and click Invoke URL.\nSince we haven’t added anything to the path, there\u0026rsquo;s no mapping, so the response is Not found.\nNow append /getPerson to the URL and hit Enter.\nYou can see that we successfully invoked the Lambda function through the API gateway. However, this is not yet the functionality we want.\nChange /getPerson to /createPerson and hit Enter.\nWe receive a Not found response because we called createPerson via the browser using the GET method, but it only supports the POST method. To resolve this and make testing easier, PostMan will be the tool of choice.\n"
},
{
	"uri": "http://nguyenhoanthao.github.io/lab3/1-setting-up-api-gateway/",
	"title": "Setting up API Gateway and create Lambda function",
	"tags": [],
	"description": "",
	"content": " API Setup\nGo to the API Gateway console:\nAWS API gateway\nPlease log in to AWS before navigating. You can choose any region to do this workshop; in this workshop, I chose US East (N. Virginia).\nScroll down to WebSocket API and click Build. In Step 1: Specify API details, fill in the following fields:\nAPI name: socket-api Route selection expression: $request.body.action Click Next. In Step 2: Add routes, click:\nAdd $connect route Add $disconnect route Add $default route In the Custom routes section:\nClick Add Custom Routes Route key: setName Click Add Custom Routes Route key: sendPublic Click Add Custom Routes Route key: sendPrivate Click Next In Step 3: Attach integrations:\nSet all Integration type fields to lambda Set all AWS Region fields to us-east-1 (depending on your workshop region) We don\u0026rsquo;t have a Lambda function yet, so there\u0026rsquo;s no option available here. We will create a Lambda function and then return to continue setting up the API.\nCreate Lambda Function\nGo to the Lambda console: AWS Lambda\nClick Create function. Select Author from scratch: Function name: chat-api-handler Runtime: Node.js 20.x Architecture: x86_64 Keep the default values. Then click Create function. A success message will appear indicating the Lambda function has been created. Copy the Function ARN for the next step. Now that we have a Lambda function, we can return to the API setup tab to continue.\nContinue API Setup\nReturn to the API tab at Step 3. In the Lambda function fields, select or paste the Function ARN copied earlier. Then click Next. In Step 4: Add stages:\nFill in Stage name: production. Then click Next. Next, review the information and click Create and deploy. A success message will appear indicating the API has been created. Go to the Stages tab, where you\u0026rsquo;ll see the WebSocket URL and connections URL. Note these URLs for use in the following steps. "
},
{
	"uri": "http://nguyenhoanthao.github.io/lab1/1-setting-up-sns/",
	"title": "Setting up SNS",
	"tags": [],
	"description": "",
	"content": "Setting up SNS Head to the SNS console:\nAWS SNS Console Please log in to AWS before navigating, you can choose any region to do this workshop. In this workshop, I chose to do it in the US East region (N. Virginia).\nCreate a New Topic:\nClick on Create topic. Set the Type to “Standard”. Set the Name to “API-Messages”. Under Access policy, leave the Method as “Basic”. Change Define who can publish messages to the topic to Only the specified AWS account and enter your account ID(found in the top right of the console). Change Define who can subscribe to this topic to Only the specified AWS account and enter your account ID again. In a real-world scenario, further restriction to only specific resources is recommended, but for this temporary setup, locking down to just the account is sufficient and safe enough.\nLeave all other options as default. Click on Create topic. Create a Subscription:\nOn the next page, click on Create subscription. Change the Protocol to “Email”. In the Endpoint field, enter your personal email. Click Create subscription. Confirm Your Subscription:\nYou will receive a confirmation email shortly after, with a link you need to click on. This confirms that you’re happy to receive emails from the topic and prevents spam from being sent via SNS. Side note: The confirmation email may go to Spam in Gmail, so don’t forget to check there. Your subscription should now be in the Confirmed state. "
},
{
	"uri": "http://nguyenhoanthao.github.io/",
	"title": "Amazon API Gateway",
	"tags": [],
	"description": "",
	"content": "Amazon API Gateway Amazon API Gateway is a fully managed service by AWS that makes it easy for developers to create, publish, maintain, monitor, and secure APIs at any scale. It allows you to build scalable and robust APIs that applications can use to interact with backend services like AWS Lambda, DynamoDB, or external HTTP services.\nTypes of APIs in Amazon API Gateway: 1. REST APIs (RESTful APIs) Introduction: This is the first API type supported by API Gateway, following the REST (Representational State Transfer) architecture, a popular standard for building web services. Main Features: Supports all HTTP methods such as GET, POST, PUT, DELETE, etc. Integrates with AWS Lambda, DynamoDB, and other AWS services or external HTTP/HTTPS endpoints. Provides powerful features such as caching, throttling, and rate limiting. Supports various security solutions like Amazon Cognito, IAM roles, and Lambda Authorizers. Manages multiple API versions through \u0026ldquo;Stages\u0026rdquo; (environments like dev, test, prod). Use Case: Suitable for APIs that require full features, scalability, complex authentication, detailed monitoring, and tight integration with AWS services. 2. HTTP APIs Introduction: HTTP APIs are a lighter, cheaper version of REST APIs, optimized for better performance and lower costs. Main Features: Supports basic HTTP methods like GET, POST, PUT, PATCH, DELETE. Easily integrates with AWS Lambda and external HTTP/HTTPS services. Provides basic security features, supporting JWT Authorizers (OpenID Connect and Amazon Cognito). Lower latency than REST APIs and more cost-effective. Use Case: Ideal for APIs that have simple requirements, low costs, high performance without needing the complexity of REST APIs. 3. WebSocket APIs Introduction: WebSocket APIs are designed for two-way, real-time communication, suitable for applications like chat, live notifications, and services requiring continuous connections. Main Features: Supports two-way communication between client and server without re-establishing connections for each request. Integrates with AWS Lambda and other services to handle real-time messaging. Manages connections, including tracking and disconnecting users. Supports message routing based on the content of the message. Use Case: Suitable for real-time applications such as live chat, online games, and interactive services. Summary of Features for Each API Type: REST APIs: Full-featured, supports caching, throttling, rate limiting, extended security options, and tight AWS integration. HTTP APIs: Lighter, faster, and cheaper, but lacks advanced features like REST APIs. Focuses on simple APIs with minimal requirements. WebSocket APIs: Supports real-time, two-way communication, suitable for applications like chat and real-time notifications. Comparison: API Type Main Features Use Cases REST APIs Full-featured, strong security, extensive integration Complex APIs requiring scalability, security, and feature richness HTTP APIs Lightweight, faster, cheaper, simple security Applications requiring high performance, low cost, and simplicity WebSocket APIs Real-time, two-way communication, continuous connection Real-time applications (chat, notifications, games) Amazon API Gateway provides flexibility to choose the right API type based on the specific needs of your application, from traditional web services and microservices to real-time applications.\nAnd in this workshop we will practice 3 lab exercises to better understand AWS API gateway.\nMain Content REST APIs with Lambda, Mock, and AWS Service integrations HTTP APIs with Lambda and Postman WebSocket APIs with Lambda and wscat "
},
{
	"uri": "http://nguyenhoanthao.github.io/lab1/",
	"title": "REST APIs with Lambda, Mock, and AWS Service integrations",
	"tags": [],
	"description": "",
	"content": "Overview We’re going to set up an API Gateway REST API, with a few different endpoints, including Mock, Lambda, and AWS service (SNS) integrations.\nYou can read about the differences between REST and HTTP APIs here: https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-vs-rest.html\nIn this lab, you will learn how to use REST APIs using API Gateway in AWS, along with Mock, Lambda, and AWS Services Integration. This will give you experience with all of these services as well as how to implement simple, serverless, event-driven back-end architectures.\nI will be creating this lab in the US East region (N. Virginia), so all links to the console will be there. Make sure you change region if you’re deploying elsewhere.\nMain Content Setting up SNS Create the Lambda Create the API Testing the API Cleaning up resources "
},
{
	"uri": "http://nguyenhoanthao.github.io/lab2/2-http-api-experiment-with-postman/",
	"title": "HTTP APIs Experiment with Postman",
	"tags": [],
	"description": "",
	"content": "Postman is a popular tool used for developing, testing, and documenting APIs. It provides a simple, user-friendly interface that allows you to easily send HTTP requests, receive responses from the server, and test API endpoints. (Download Postman here)\nUsing Postman\nPostman main interface: Create a new tab. Go back to the API Gateway tab and copy the Invoke URL. In Postman, select the GET method and paste the Invoke URL, then append /getPerson to the URL. Click Send, and we still receive the response Hello from Lambda!. Now, let\u0026rsquo;s create a key-value pair: personid - personid 123. You can see these two parameters are added to the query URL. Click Send, and again, we get the response Hello from Lambda!. Next, we will create a new tab with the POST method and append /createPerson to the URL. Click on the Body tab and select raw. Add the following raw data: {\r\u0026#34;firstName\u0026#34;: \u0026#34;Daniel\u0026#34;,\r\u0026#34;lastName\u0026#34;: \u0026#34;G\u0026#34;,\r\u0026#34;email\u0026#34;: \u0026#34;myEmail@gmail.com\u0026#34;\r} Experimenting with Postman\nGo back to the Lambda function tab and update the Lambda function code as follows: import json import uuid GET_RAW_PATH = \u0026#34;/getPerson\u0026#34; CREATE_RAW_PATH = \u0026#34;/createPerson\u0026#34; def lambda_handler(event, context): print(json.dumps(event, indent=2)) # Print the entire event for inspection # Check if rawPath exists in the event if \u0026#39;rawPath\u0026#39; in event: # Handle the GET method if event[\u0026#39;rawPath\u0026#39;] == GET_RAW_PATH: print(\u0026#39;Received getPerson request\u0026#39;) personId = event[\u0026#39;queryStringParameters\u0026#39;][\u0026#39;personid\u0026#39;] print(\u0026#34;with param personId=\u0026#34; + personId) return { \u0026#34;firstName\u0026#34;: \u0026#34;Daniel \u0026#34; + personId, \u0026#34;lastName\u0026#34;: \u0026#34;G\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;myEmail@gmail.com\u0026#34; } # Handle the POST method elif event[\u0026#39;rawPath\u0026#39;] == CREATE_RAW_PATH and event[\u0026#39;requestContext\u0026#39;][\u0026#39;http\u0026#39;][\u0026#39;method\u0026#39;] == \u0026#39;POST\u0026#39;: print(\u0026#39;Received createPerson request\u0026#39;) # Decode the body from JSON decodedBody = json.loads(event[\u0026#39;body\u0026#39;]) firstname = decodedBody.get(\u0026#39;firstname\u0026#39;, \u0026#39;Unknown\u0026#39;) # Prevent error if \u0026#39;firstname\u0026#39; is missing print(\u0026#39;with param firstname=\u0026#39; + firstname) # Generate an ID for the new user and return it return { \u0026#34;statusCode\u0026#34;: 200, \u0026#34;body\u0026#34;: json.dumps({ \u0026#34;personId\u0026#34;: str(uuid.uuid1())}) } # If rawPath is not found or invalid return { \u0026#34;statusCode\u0026#34;: 400, \u0026#34;body\u0026#34;: json.dumps({\u0026#34;message\u0026#34;: \u0026#34;Invalid request\u0026#34;}) } Functionality of the Code\nGET /getPerson:\nRetrieves a person\u0026rsquo;s information based on personId from the queryStringParameters. Returns the person\u0026rsquo;s first name, last name, and email. POST /createPerson:\nCreates a new person with the firstname taken from the request body. Returns a randomly generated personId. Click Deploy to deploy the Lambda function.\nReturn to Postman in the GET method tab and click Send. We receive the following response: Next, go to the POST method tab and click Send. Click Send again, and we receive a different (random) personId. "
},
{
	"uri": "http://nguyenhoanthao.github.io/lab2/",
	"title": "HTTP APIs with Lambda and Postman",
	"tags": [],
	"description": "",
	"content": "Overview HTTP APIs in AWS API Gateway are a lightweight API type optimized for applications that need simplicity, speed, and low cost. This is a simpler version compared to REST APIs, designed to handle common use cases such as building back-end services for web or mobile applications or integrating microservices.\nKey Features of HTTP APIs: Higher performance: HTTP APIs offer lower latency than REST APIs due to a streamlined design, resulting in faster responses. Low cost: HTTP APIs are typically cheaper than REST APIs by eliminating complex features that not all applications need, such as Stage variables or Lambda authorizers. Easy integration: HTTP APIs easily integrate with many other AWS services such as AWS Lambda, Amazon S3, and external HTTP services. Support for HTTP methods: HTTP APIs support all basic HTTP methods like GET, POST, PUT, PATCH, and DELETE, making it easy to build endpoints that follow common API standards. Authentication: HTTP APIs support authentication and authorization methods, including the use of JWT (JSON Web Tokens) with OpenID Connect (OIDC) providers and Amazon Cognito. No support for advanced features: HTTP APIs do not include some advanced features of REST APIs like Stage variables, Request Validation, or API Gateway Authorizers (although JWT authorizers are supported). Use Cases: Building simple web or mobile backends with basic API requirements. Integrating microservices or simple applications with low cost and low latency. Services that need to integrate with AWS Lambda, DynamoDB, or other HTTP services without requiring advanced REST API features. In this lab, we will explore how to build an HTTP API and experiment with it using Postman. This lab will guide you through creating HTTP APIs using the API gateway in AWS. We will create two routes for the API, the first route will be /getPerson which will be a GET API and the second route will be /createPerson which will be a POST API. They will be supported by a single Lambda function, and we will add some conditional logic to the Lambda function so that it can handle the two endpoints of these two routes.\nMain Content Setting up HTTP API and Create the Lambda function HTTP API Experiment with Postman Clean Up Resources "
},
{
	"uri": "http://nguyenhoanthao.github.io/lab3/2-lambda-function-code/",
	"title": "Lambda function code",
	"tags": [],
	"description": "",
	"content": " Lambda Function Code\nGo to the Lambda Console:\nAWS Lambda\nAccess the chat-api-handler function. In the Code source section, copy and paste the following code: import { ApiGatewayManagementApiClient, PostToConnectionCommand } from \u0026#34;@aws-sdk/client-apigatewaymanagementapi\u0026#34;; const ENDPOINT = \u0026#39;2ur7m6qwv6.execute-api.us-east-1.amazonaws.com/production\u0026#39;; /* IMPORTANT: Remove \u0026#39;https://\u0026#39; and \u0026#39;@connections\u0026#39; from the connection URL you copy. Example: Connection URL https://xxxxxxxxxxx/execute-api.us-east-1.amazonaws.com/production/@connections becomes: ENDPOINT = \u0026#39;xxxxxxxxxxx/execute-api.us-east-1.amazonaws.com/production/\u0026#39; */ const client = new ApiGatewayManagementApiClient({ endpoint: `https://${ENDPOINT}` }); /** * Send a message to a client via Connection ID */ const sendToOne = async (id, body) =\u0026gt; { try { const command = new PostToConnectionCommand({ ConnectionId: id, Data: Buffer.from(JSON.stringify(body)), }); await client.send(command); } catch (err) { console.error(`Error sending message to ${id}:`, err); } }; /** * Send a message to all clients */ const sendToAll = async (ids, body) =\u0026gt; { const all = ids.map(i =\u0026gt; sendToOne(i, body)); return Promise.all(all); }; export const handler = async (event) =\u0026gt; { if (event.requestContext) { const connectionId = event.requestContext.connectionId; const routeKey = event.requestContext.routeKey; let body = {}; try { if (event.body) { body = JSON.parse(event.body); } } catch (err) { console.error(\u0026#39;Failed to parse event body:\u0026#39;, err); } // Handle specific actions based on body.action if (body.action === \u0026#34;sendPublic\u0026#34;) { await sendToAll([connectionId], { publicMessage: \u0026#39;this is a public message\u0026#39; }); } else if (body.action === \u0026#34;sendPrivate\u0026#34;) { await sendToOne(connectionId, { privateMessage: \u0026#39;this is a private message\u0026#39; }); } // Handle default WebSocket routes ($connect, $disconnect, ...) switch (routeKey) { case \u0026#39;$connect\u0026#39;: console.log(`New connection: ${connectionId}`); break; case \u0026#39;$disconnect\u0026#39;: console.log(`Disconnected: ${connectionId}`); break; default: console.log(`Unhandled route: ${routeKey}`); } } const response = { statusCode: 200, body: JSON.stringify(\u0026#39;Message processed\u0026#39;), }; return response; }; The above code is a handler function for AWS Lambda, designed to process WebSocket events from the API Gateway. Below is an overview of the key components:\nInitializing API Gateway client:\nApiGatewayManagementApiClient and PostToConnectionCommand are imported from the AWS SDK to send messages via WebSocket based on the Connection ID. ENDPOINT is the URL of the WebSocket API, used to send messages. sendToOne function:\nUsed to send messages to a client through Connection ID. Creates a PostToConnectionCommand to send data (messages) to a client and sends this command via client.send(command). sendToAll function:\nSends messages to all clients in the Connection IDs list. Uses Promise.all to ensure the message is sent to all clients. Main handler function:\nReceiving events: Executes when API Gateway receives a WebSocket event (such as a new connection, disconnection, or a message sent from a client). Processing event information: Checks the attributes from event.requestContext to retrieve information about Connection ID and Route Key (which defines the event type such as $connect, $disconnect). If there is a body, the function will try to parse it as JSON for processing. Handling actions: Based on body.action (e.g., sendPublic, sendPrivate), the function will send public or private messages via WebSocket. Handling default WebSocket routes: $connect: Logs when a new connection is made. $disconnect: Logs when a client disconnects. In summary, this code sends messages via WebSocket to clients based on client actions, and it also handles connection and disconnection events from the WebSocket API Gateway.\nDeployment\nAfter pasting the above code, click Deploy.\nA notification will confirm that the Lambda function has been updated.\nGo to the Configuration tab -\u0026gt; Permissions.\nExpand the Role name tab.\nNow, we have access to the IAM tab.\nClick Add permission -\u0026gt; Attach policies.\nChoose AmazonAPIGatewayInvokefullAccess.\nClick Add permission.\nA notification will confirm that the permission has been successfully added.\nGo back to the Lambda tab, and we can see that the policy has been attached.\n"
},
{
	"uri": "http://nguyenhoanthao.github.io/lab1/2-create-the-lambda/",
	"title": "Create the Lambda",
	"tags": [],
	"description": "",
	"content": " Head to the Lambda console:\nAWS Lambda Console\nCreate a New Function:\nClick on Create function. Leave Author from scratch selected. Set the Function name to api-return-ip. Set the Runtime to “Python 3.9”. Leave the Architecture as “x86_64”. Click on Create function. Add Code to the Lambda Function:\nIn the Code tab, enter the following code:\ndef lambda_handler(event, context): return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;headers\u0026#39;: {}, \u0026#39;body\u0026#39;: event[\u0026#39;requestContext\u0026#39;][\u0026#39;identity\u0026#39;][\u0026#39;sourceIp\u0026#39;], \u0026#39;isBase64Encoded\u0026#39;: False } This is a very basic function that simply returns the IP address of the requester (you).\nDon’t forget to click on Deploy to save the function. "
},
{
	"uri": "http://nguyenhoanthao.github.io/lab2/3-cleaning-up/",
	"title": "Clean Up Resources",
	"tags": [],
	"description": "",
	"content": " Access the AWS Lambda Console\nAWS Lambda\nSelect DemoAppFunction. Click Action -\u0026gt; Delete. Confirm deletion. Access the AWS API Console\nAWS API\nSelect Persons. Click Delete. Confirm deletion. "
},
{
	"uri": "http://nguyenhoanthao.github.io/lab3/3-testing-the-websocket-using-wscat/",
	"title": "Testing the WebSocket APIs Using-wscat",
	"tags": [],
	"description": "",
	"content": " Install wscat\nInstall wscat in the terminal. Command: npm install -g wscat. Navigate to the API gateway tab, copy the WebSocket URL. Now, open two terminal windows (window 1 and window 2). In window 1, run the command: wscat -c wss://2ur7m6qwv6.execute-api.us-east-1.amazonaws.com/production/ Remember to replace the WebSocket URL with the one you copied earlier.\nPress Enter. You have successfully connected to the WebSocket. Do the same for window 2. From window 1, send a JSON to the Socket: {\u0026quot;action\u0026quot; : \u0026quot;sendPublic\u0026quot;} You will receive a response: From window 2, send a JSON to the Socket: {\u0026quot;action\u0026quot; : \u0026quot;sendPrivate\u0026quot;} You will receive a response: You can see that when a user sends a message to the Socket, only that user receives a response. Therefore, we will update the Lambda function code so that when a user sends a message, all other users will receive the response.\nUpdate Lambda Function Code\nWe will use the following code:\nimport { ApiGatewayManagementApiClient, PostToConnectionCommand } from \u0026#34;@aws-sdk/client-apigatewaymanagementapi\u0026#34;; const ENDPOINT = \u0026#39;2ur7m6qwv6.execute-api.us-east-1.amazonaws.com/production\u0026#39;; /* IMPORTANT: Remove \u0026#39;https://\u0026#39; and \u0026#39;@connections\u0026#39; from the connection URL you copy. Example: Connection URL https://xxxxxxxxxxx/execute-api.us-east-1.amazonaws.com/production/@connections becomes: ENDPOINT = \u0026#39;xxxxxxxxxxx/execute-api.us-east-1.amazonaws.com/production/\u0026#39; */ const client = new ApiGatewayManagementApiClient({ endpoint: `https://${ENDPOINT}` }); const names = {}; /** * Sends a message to one client via Connection ID */ const sendToOne = async (id, body) =\u0026gt; { try { const command = new PostToConnectionCommand({ ConnectionId: id, Data: Buffer.from(JSON.stringify(body)), }); await client.send(command); } catch (err) { console.error(`Error sending message to ${id}:`, err); } }; /** * Sends a message to all clients */ const sendToAll = async (ids, body) =\u0026gt; { const all = ids.map(i =\u0026gt; sendToOne(i, body)); return Promise.all(all); }; export const handler = async (event) =\u0026gt; { if (event.requestContext) { const connectionId = event.requestContext.connectionId; const routeKey = event.requestContext.routeKey; let body = {}; try { if (event.body) { body = JSON.parse(event.body); } } catch (err) { console.error(\u0026#39;Failed to parse event body:\u0026#39;, err); } // Handle specific actions based on body.action switch (routeKey) { case \u0026#39;$connect\u0026#39;: console.log(`New connection: ${connectionId}`); break; case \u0026#39;$disconnect\u0026#39;: await sendToAll(Object.keys(names), { systemMessage: `${names[connectionId]} has left the chat` }); delete names[connectionId]; await sendToAll(Object.keys(names), { members: Object.values(names) }); console.log(`Disconnected: ${connectionId}`); break; case \u0026#39;setName\u0026#39;: names[connectionId] = body.name; await sendToAll(Object.keys(names), { members: Object.values(names) }); await sendToAll(Object.keys(names), { systemMessage: `${names[connectionId]} has joined the chat` }); break; case \u0026#39;sendPublic\u0026#39;: await sendToAll(Object.keys(names), { publicMessage: `${names[connectionId]}: ${body.message}` }); break; case \u0026#39;sendPrivate\u0026#39;: const to = Object.keys(names).find(key =\u0026gt; names[key] === body.to); if (to) { await sendToOne(to, { privateMessage: `${names[connectionId]}: ${body.message}` }); } else { await sendToOne(connectionId, { errorMessage: `User ${body.to} not found.` }); } break; default: console.log(`Unhandled route: ${routeKey}`); } } const response = { statusCode: 200, body: JSON.stringify(\u0026#39;Message processed\u0026#39;), }; return response; }; The function to send a message to all connected clients is implemented through the sendToAll function. This function takes a list of Connection IDs (ids), representing all currently connected clients, along with the message content (body) to send.\nClick Deploy to update. A successful update message appears. Test the Updated Lambda Function\nOpen two terminal windows again to connect to the WebSocket.\nIn window 1:\n{\u0026quot;action\u0026quot;: \u0026quot; setName \u0026quot;, \u0026quot; name \u0026quot;: \u0026quot; bob \u0026quot;} You will receive a response: In window 2:\n{\u0026quot;action\u0026quot;: \u0026quot; setName \u0026quot;, \u0026quot; name \u0026quot;: \u0026quot; alice \u0026quot;} You will receive a response: Now, go back to window 1 and see the response: Continue in window 2:\n{\u0026quot;action\u0026quot;: \u0026quot;sendPublic\u0026quot;, \u0026quot;message\u0026quot;: \u0026quot;Hello World!\u0026quot;} Check in window 1: Back to window 2:\n{\u0026quot;action\u0026quot;: \u0026quot;sendPrivate\u0026quot;, \u0026quot;message\u0026quot;: \u0026quot;this is private\u0026quot;, \u0026quot;to\u0026quot;: \u0026quot;bob\u0026quot;} Check in window 1: Now, disconnect from window 2:\nCtrl + C At this point, window 1 will show a disconnect message: You have just completed a series of actions involving two different windows related to sending public and private messages in a connected system. Here is a summary of the steps:\nWindow 1: Sent a request to set the name as \u0026ldquo;bob\u0026rdquo; and received a response.\nWindow 2: Sent a request to set the name as \u0026ldquo;alice\u0026rdquo; and received a similar response.\nBack to Window 1: Checked and saw a response indicating that \u0026ldquo;alice\u0026rdquo; was set in window 2.\nWindow 2: Sent a public message \u0026ldquo;Hello World!\u0026rdquo;.\nBack to Window 1: Checked and saw the public message from window 2.\nWindow 2: Sent a private message \u0026ldquo;this is private\u0026rdquo; to \u0026ldquo;bob\u0026rdquo;.\nBack to Window 1: Checked and saw the private message from \u0026ldquo;alice\u0026rdquo;.\nWindow 2: Disconnected using Ctrl + C.\nWindow 1: Received a message indicating the disconnection of window 2.\n"
},
{
	"uri": "http://nguyenhoanthao.github.io/lab1/3-create-the-api/",
	"title": "Creating the API",
	"tags": [],
	"description": "",
	"content": " Head to the API Gateway console:\nAWS API Gateway Console\nCreate a New API:\nClick on Create API. Select REST API → Build. Make sure you don’t select “REST API Private”. Leave the Protocol and Create new API options as is, and set your API name to whatever you like. Click Create API. Create a Resource for Mock Integration:\nOnce the API is created, you will see all the “Resources” (endpoints / API paths). Right now, there are none, so click Create Resource. Name this first resource “Mock”. The Resource Path is the URL path you will use to call it, so in this case, it would be something like:\nhttps://abcdef1234.execute-api.ap-southeast-2.amazonaws.com/mock Attach a Method to the Resource:\nA Method is the HTTP method that the resource (path) will accept, such as “GET”, “POST”, “DELETE”, etc.\nFor the Mock integration, we will just use “GET”.\nMake sure you are in the /Mock resource.\nClick Create Method. Select GET.\nOnce that’s done, API Gateway will present a list of possible integrations. For this one, select “Mock” and then click Create method. After saving, click on Integration Response. Click Edit. Click the tick, then in the template section, enter the following (you can replace the message with whatever you like):\n{ \u0026#34;statusCode\u0026#34;: 200, \u0026#34;message\u0026#34;: \u0026#34;This response is mocking you\u0026#34; } Click Save. Create a Resource for Lambda Integration:\nGo back to the root resource (/). Click Create Resource. Set the resource name to “Lambda” and leave the Resource Path as /Lambda. Click Create Resource. Click Create Method. This will also be a GET. On the next page, set the Integration type to “Lambda function”. Enable Lambda Proxy integration. Once you click the Lambda Function text field, it should drop down with a list of Lambda functions in that region; select the one you created earlier. Leave all other options as is and click Create method. Create a Resource for SNS Integration:\nFor this step, you will need to set up an IAM Role that API Gateway will use to publish messages to SNS.\nHead to the IAM Console.\nGo to the Roles page and click Create Role. Under Trusted entity, select AWS Service, and in the drop-down, select API Gateway. Make sure you select the radio button for API Gateway as well.\nClick Next. On the Permissions page, click Next. Lastly, set the role name to api-gw-sns-role and click Create role. Go into the role you just created, click Add permissions then Create inline policy. Go to the JSON tab and enter the following:\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;sns:Publish\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; } ] } Click Next. Set the name to SnsPublish and click Create policy. On the summary page, copy the ARN of the role you just created; you will need it for the next step. Configure SNS Integration in API Gateway:\nHead back to the API Gateway Console. Go back into your REST API. Go back to the root resource (/). Click Create Resource. Set the resource name to “SNS” and leave the Resource Path as /SNS. Click Create Resource. Click on Create Method. This one will be a “POST”. On the next page, set the Integration type to “AWS Service”. Set the AWS Region as the same region as your API / SNS (for example, ap-southeast-2). Set the AWS Service to “Simple Notification Service (SNS)”. Leave the AWS Subdomain blank. Set the HTTP method to POST. Leave the Action Type as “Use action name”. Set the Action to Publish. Under Execution Role, enter the ARN of the IAM Role you just created for SNS.(You copied it in the previous step.) Leave the rest of the form as is and click Create method. Configure Query String Parameters for SNS:\nGo to the /SNS resource, and the POST method, and click Method Request. Nhấn chọn Edit. Under URL Query String Parameters, click Add query string and enter TopicArn. Click Add query string and enter Message, then click on Save. Go back to the /SNS resource, and the POST method, and click Integration Request. Click on Edit. Under URL Query String Parameters, click Add query string parameter. Set the Name to Message and the Mapped from to method.request.querystring.Message. Click Add query string again. Set the Name to TopicArn and the Mapped from to method.request.querystring.TopicArn. Click on Save. Deploy the API:\nClick on Deploy API. In the popup window, set the Deployment stage to [New Stage] and the Stage name to v1. The Stage name can be anything and is used to direct API requests to different “versions” of the API. For example, you could have a “dev” stage, a “prod” stage, or just use standard names like v1, v2, etc. Click Deploy. Once that’s done, you will be sent to the Stage Editor page, where you can configure settings like Rate Limiting, WAF associations, caching, logs, etc. We don’t need to change any of these for this demo. At the top of the screen, you will see your API URL. Copy that URL for the next step. "
},
{
	"uri": "http://nguyenhoanthao.github.io/lab3/",
	"title": "WebSocket APIs with Lambda and WSCAT",
	"tags": [],
	"description": "",
	"content": "Overview A WebSocket API in API Gateway is a collection of WebSocket routes that are integrated with backend HTTP endpoints, Lambda functions, or other AWS services. You can use API Gateway features to help you with all aspects of the API lifecycle, from creation through monitoring your production APIs.\nAPI Gateway WebSocket APIs are bidirectional. A client can send messages to a service, and services can independently send messages to clients. This bidirectional behavior enables richer client/service interactions because services can push data to clients without requiring clients to make an explicit request. WebSocket APIs are often used in real-time applications such as chat applications, collaboration platforms, multiplayer games, and financial trading platforms.\nIn this lab, we will learn how to build a simple conversation using Lambda, WebSocket APIs, WSCAT. We build a simple real-time chat using websockets powered by AWS lambda functions and Amazon API Gateway. The application sends JSON over the websocket to send chat messages and notifications in real time, over a two-way communication line, to all chat users.\nMain Content Setting up API Gateway and Create the Lambda function Lambda function code Testing the websocket using wscat Clean up resources "
},
{
	"uri": "http://nguyenhoanthao.github.io/lab3/4-cleaning-up/",
	"title": "Clean up resources",
	"tags": [],
	"description": "",
	"content": " Access the AWS Lambda Dashboard\nAWS Lambda\nSelect chat-api-handler.\nClick Action -\u0026gt; Delete. Confirm deletion. Access the AWS API Dashboard\nAWS API\nSelect Socket API.\nClick Delete. Confirm deletion. "
},
{
	"uri": "http://nguyenhoanthao.github.io/lab1/4-testing-the-api/",
	"title": "Testing the API",
	"tags": [],
	"description": "",
	"content": "The Lambda and Mock resources can be tested in the browser. By default, any URL you enter into your browser performs a GET request (and remember, only our Lambda and Mock resources have the GET method set).\nMock If we visit our API URL and append /Mock, we should see the response we entered earlier. The reason we want a JSON output rather than a friendly human-readable one is because working with JSON in programming languages makes things much easier. Your code or application could read the statusCode key and see a 200 value, and then it could read the message key and see its value.\nLambda Now, if we visit our /Lambda URL, we should see our function response (your IP address). SNS GUI (AWS Console) The API Gateway console provides a handy way to test your API. On the testing page, under Query Strings, enter the following. Replace the TopicArn with your SNS Topic ARN, and the Message with whatever you like:\nTopicArn=arn:aws:sns:REGION:ACCOUNT-ID:API-Messages\u0026amp;Message=Cats+Are+Amazing If you want to use spaces in your message, because query parameters are URL encoded, spaces need to be replaced with a +.\nScroll down and click Test. Check email "
},
{
	"uri": "http://nguyenhoanthao.github.io/lab1/5-cleaning-up/",
	"title": "Clean up resources",
	"tags": [],
	"description": "",
	"content": " Head to the API Gateway console: API Gateway Console\nSelect the API you created, and click Delete. Confirm deletion. Head to the SNS console: SNS Console\nGo to Topics, select the topic you created earlier, and click Delete. Confirm deletion. Go to Subscriptions, select the Subscriptions you created earlier, and press Delete. Head to the IAM console: IAM Console\nUnder Roles, search for api-gw-sns-role. Select the role you created earlier, and click Delete. Type api-gw-sns-role into the confirmation field, and click Delete. Head to the Lambda console: Lambda Console\nSelect the function you created earlier, and click Actions then Delete. Enter delete in the confirmation window, and then click Delete. Delete additional roles created when creating a Lambda function. Click on Delete. Head to the CloudWatch Logs console: CloudWatch Logs Console\nSearch for the api-return-ip Log Group, select the log group, click Actions then Delete. In the confirmation popup, click Delete. "
},
{
	"uri": "http://nguyenhoanthao.github.io/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://nguyenhoanthao.github.io/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]